TITLE:: OSCMapper
summary:: An abstraction layer for OSC controllers
categories:: OSC Controllers
related:: Classes/Bus, Classes/OSCdef, Classes/Ndef, Classes/Pdefn

DESCRIPTION::

OSCMapper is a Quark which intents to simplify the process of controlling SuperCollider with external OSC controllers such as TouchOSC.

STRONG::Learn OSC controls::

With OSCMapper it is possible to automatically create an OSCMapper layout according to the data it received which is often refered to as learning of controllers.
Simply turn OSCMapper into learning mode

code::
OSCMapper.learn;
::

move the controllers (which should send its messages to the sclang standard port 57120, see link::Classes/NetAddr#*langPort::) and once finished stop the learning process which will output a new controller

code::
OSCMapper.finishLearn(\controller);
::

The detected mapping will be shown at the post video.
There are

LIST::
## link::Classes/OSCMapperFader:: for faders with floating point range
## link::Classes/OSCMapperPush:: for binary buttons
## link::Classes/OSCMapperXY:: for 2 dimensional faders
## link::Classes/OSCMapperAccXYZ:: for sensory data
::

which all use link::Classes/OSCMapperElement:: as foundation.


STRONG::How to use the OSC values::

Assuming you have a OSC controller which is sending on address code::/1/fader:: and you have set up OSCMapper for this address you can access the value

LIST::
## as a link::Classes/Ndef::

code::
// the osc mapper we created earlier
// can be accessed in Ndef style
o = OSCMapper(\controller);

Ndef(\mySine, {SinOsc.ar!2 * o['/1/fader1'].asNdef}).play;

Ndef(\mySine).clear(2);
::

## as a link::Classes/Bus::
code::
// use the default synth
s = Synth(\default);
s.map(\amp, o['/1/fader1']);
s.free;
::

## as a link::Classes/Pdefn::
code::
(
p = Pbind(
	\instrument, \default,
	\dur, 0.5,
	\degree, Pxrand((0..10), inf),
	\amp, o['/1/fader1'].asPdefn,
).play;
)

p.stop;
::

## as a raw value

code::
o['/1/fader1'].value;
::

## via a callback on change

code::
o['/1/fader1'].callback = {|v| "value is now %".format(v).postln};
// and free the callback
o['/1/fader1'].callback = {};
::
::

STRONG::Creating a layout manually::

In case you do not want to learn OscMapper everytime you boot up SuperCollider
you can also define the layout manually like

code::
(
o = OSCMapper(name: \controller, layout: (
    '/1/fader1': OSCMapperFader(
        altName: \fader1,
        defaultValue: 0.5,
        transformer: linlin(_, 0.0, 1.0, 0.5, 10.0),
        callback: {|v| ["received a value", v].postln;},
        lag: 0.5,
    ),
    '/1/xy1': OSCMapperXY(
        altName: \touchPanel
    ),
));
)
::

By providing an code::altName:: you can access the value also via this name on the mapper, e.g.

code::
o[\fader1].value;
::

STRONG::Using a preset::

The presets from TouchOSC are already provided and can be simply loaded via

code::
o = OSCMapper.mix2(name: \controller);

o['/1/fader1'].value;
::

CLASSMETHODS::

METHOD:: new
Will create a new OSCMapper.
Will also add a link::Classes/Main#-addOSCRecvFunc:: which allows us to search trough all OSC messages.
argument:: name
Should be unique as we also allow to access the instances in an link::Classes/Ndef:: manner.
argument:: layout
An link::Classes/Event:: where key is the OSC address and the value is a link::Classes/OSCMapperElement:: which accepts the value.
argument:: port
Defaults to link::Classes/NetAddr#*langPort:: and allows to listen on other ports as well if set.

METHOD:: learn
Puts OSCMapper in capture mode.
Should be followed by link::Classes/OSCMapper#*finishLearn::

METHOD:: finishLearn
Will create a OSCMapper according to the messages that were received since link::Classes/OSCMapper#*learn:: was called.
argument::name
See link::Classes/OSCMapper#*new::.

METHOD:: mix2
Constructor with layout for TouchOSC preset Mix 2.
For other args see link::Classes/OSCMapper#*new::.
argument:: name
argument:: port


METHOD:: mix2iPad
Constructor with layout for TouchOSC preset Mix 2 iPad.
For other args see link::Classes/OSCMapper#*new::.
argument:: name
argument:: port

METHOD:: all
Will return an link::Classes/Event:: with all registered OSCMappers where the key is the name.

METHOD:: clearAll
Removes all instances of OSCMapper.

METHOD:: echo
Allows to output the currently received OSC messages, like link::Classes/OSCFunc#*trace::.
This is useful to identify the touched controls.
argument:: echoBool
if code::true:: it will print the received values to the Post window. When set to code::false:: it will stop posting.

PRIVATE:: initClass

PRIVATE:: prCreateOscListener

PRIVATE:: isLearning

PRIVATE:: initListener

PRIVATE:: learnCapture

PRIVATE:: listenOnOSC


INSTANCEMETHODS::

PRIVATE:: init

METHOD:: at
Allows to access the addresses via e.g. code::o['/1/fader1']::
argument:: address
The address or altname given.

METHOD:: layout
Allows to access and update the given layout.
Note that you can only update the whole dictionary at once, so in case of incremental updates you need to take care of this for yourself.

METHOD:: clear

Removes any server resources and also any callbacks in the language.


EXAMPLES::

STRONG::Multitoggles as step sequencer::

code::
// TODO
::
